<html>

<head>
  <title>Final Computer Graphics Project</title>
  <link rel="stylesheet" type="text/css" href="CSS/style.css">
</head>

<style>
  body {
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }
</style>

<body>

  <!--include the three.js library-->
  <script src="js/three.js">
  </script>
  <!--and the trackball code-->
  <script src="js/OrbitControls.js"></script>
  <script src="js/PLYLoader.js"></script>
  <script src="js/dat.gui.min.js"></script>

  <!-- <div id="texture">
  Introduce the texture:
  <form id="texture_form">
    <select id="txt">
      <option value="img/brick_bump.jpg">Bricks</option>
      <option value="img/wood_1.jpg">Wood 1</option>
      <option value="img/wood_2.jpg">Wood 2</option>
    </select>
  </form>
  </div> -->

  <script>
    var FLOOR_WIDTH = 80; //x-axis
    var FLOOR_HEIGHT = 0.1; //y-axis
    var FLOOR_LENGTH = 110; //z-axis

    var WALL_HEIGHT = 15;
    var WALL_THICKNESS = 0.4;

    var WALL_LEFT_LENGTH = 0.65;
    var WALL_LEFT2_LENGTH = 0.45;
    var WALL_LEFT3_LENGTH = 0.2;
    var WALL_RIGHT_LENGTH = 0.8;
    var WALL_TOP_WIDTH = 0.35;

    var OFFSET = 0.1;

    var WallSideEnum = Object.freeze({"none":-1, "right":0, "left":1, "top":2, "bottom":3, "front":4, "back":5});

    //Create the scene
    var scene = new THREE.Scene();
    scene.background = new THREE.Color(0x93C47D);

    //Create the webgl renderer
    var renderer = new THREE.WebGLRenderer();

    renderer.setSize(window.innerWidth, window.innerHeight);

    //Add the renderer to the current document
    document.body.appendChild(renderer.domElement);

    //Camera creation
    var ratio = window.innerWidth / window.innerHeight;
    //Create the perspective camera
    var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 2000);
    camera.position.set(60, 25, 60);


    var cameraLight = new THREE.PointLight(new THREE.Color(1, 1, 1), (1.2));
    camera.add(cameraLight);

    var axesHelper = new THREE.AxesHelper(300,300,300);
    scene.add( axesHelper );


    // //Light addition -> Camera Light
    // var cameraLight = new THREE.PointLight(new THREE.Color(1, 1, 1), (2));
    // camera.add(cameraLight);
    scene.add(camera);

    var geometry_floor = new THREE.CubeGeometry(FLOOR_WIDTH, FLOOR_HEIGHT, FLOOR_LENGTH);
    var geometry_wall_parallel = new THREE.CubeGeometry(FLOOR_WIDTH-0.2, WALL_HEIGHT, WALL_THICKNESS);
    var geometry_wall_parallel_out = new THREE.CubeGeometry(FLOOR_WIDTH, WALL_HEIGHT, WALL_THICKNESS);
    var geometry_wall_parallel_02 = new THREE.CubeGeometry(FLOOR_WIDTH*0.25, WALL_HEIGHT, WALL_THICKNESS);
    var geometry_wall_parallel_03 = new THREE.CubeGeometry(FLOOR_WIDTH*WALL_TOP_WIDTH, WALL_HEIGHT, WALL_THICKNESS);
    var geometry_wall_parallel_04 = new THREE.CubeGeometry(FLOOR_WIDTH*0.434, WALL_HEIGHT, WALL_THICKNESS);
    var geometry_wall_orthogonal = new THREE.CubeGeometry(WALL_THICKNESS, WALL_HEIGHT, FLOOR_LENGTH);
    var geometry_wall_orthogonal_08 = new THREE.CubeGeometry(WALL_THICKNESS, WALL_HEIGHT, FLOOR_LENGTH*WALL_RIGHT_LENGTH);
    var geometry_wall_orthogonal_06 = new THREE.CubeGeometry(WALL_THICKNESS, WALL_HEIGHT, FLOOR_LENGTH*WALL_LEFT_LENGTH);
    var geometry_wall_orthogonal_04 = new THREE.CubeGeometry(WALL_THICKNESS, WALL_HEIGHT, FLOOR_LENGTH*WALL_LEFT2_LENGTH-0.2);
    var geometry_wall_orthogonal_02 = new THREE.CubeGeometry(WALL_THICKNESS, WALL_HEIGHT, FLOOR_LENGTH*WALL_LEFT3_LENGTH);
    var geometry_wall_diagonal = new THREE.CubeGeometry(WALL_THICKNESS, WALL_HEIGHT, FLOOR_LENGTH*0.287);

    var floor = loadTexture('http://localhost:8000/img/txtr_floor.jpg', geometry_floor, 5, WallSideEnum.none);
    scene.add(floor);

    buildWalls();

    var livingroom_light = new THREE.PointLight(new THREE.Color(1, 1, 1), 1, 100);
    livingroom_light.position.set(3, 3, 0);
    scene.add(livingroom_light);

    //Resizing function -> adjust cube position and size to the window size
    var MyResize = function() {
      var width = window.innerWidth;
      var height = window.innerHeight;
      //Update renderer size
      renderer.setSize(width, height);
      //Update camera aspect ratio
      camera.aspect = width / height;
      //Update projection matrix from the new values
      camera.updateProjectionMatrix();
      //Render the scene again
      renderer.render(scene, camera);
    }

    controls = new THREE.OrbitControls(camera);

    //Updating function
    var MyUpdateLoop = function() {
      controls.update();
      //Call the render with the scene and the camera
      renderer.render(scene, camera);
      //Finally perform a recursive call to update again
      //THis must be called because the mouse changes the camera position
      requestAnimationFrame(MyUpdateLoop);
    };

    requestAnimationFrame(MyUpdateLoop);
    var render = function() {
      requestAnimationFrame(render);
      renderer.render(scene, camera);
    };


    function loadTexture(uri, geometry, rep, outsideWall) {
      var textureLoader = new THREE.TextureLoader();
      THREE.ImageUtils.crossOrigin = true;
      textureLoader.crossOrigin = true;
      var texture = new THREE.TextureLoader().load(uri);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(rep, rep);
      var material = new THREE.MeshLambertMaterial({
        map: texture
      });

      var wall_texture = new THREE.TextureLoader().load('http://localhost:8000/img/txtr_brick_brown_light.jpg');
      wall_texture.wrapS = wall_texture.wrapT = THREE.RepeatWrapping;
      wall_texture.repeat.set(8, 8);
      var material_outsidewall = new THREE.MeshLambertMaterial({
        map: wall_texture
      });
      var materials = [
        material, // Right side
        material, // Left side
        material, // Top side
        material, // Bottom side
        material, // Front side
        material  // Back side
      ];
      if (outsideWall != WallSideEnum.none)
        materials[outsideWall] = material_outsidewall;

      return new THREE.Mesh(geometry, materials);
    }




    /*---------------------Addition of all models to the scene--------------------*/

    //Bed model

    var bed_color = new THREE.Color(0.8, 1, 0.6);
    var bed_material = new THREE.MeshPhongMaterial();

    bed_material.color = bed_color;
    bed_material.shininess = 0;

    var loader = new THREE.PLYLoader();
    var bed_mesh = null;
    loader.load('Final Models/Bed1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(25 / size.length(), 25 / size.length(), 25 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);

      combined.multiply(tra);
      combined.multiply(sca);

      bed_mesh = new THREE.Mesh(geometry, bed_material);

      bed_mesh.applyMatrix(sca);
      bed_mesh.name = "loaded_mesh";
      bed_mesh.position.x -= FLOOR_WIDTH/3;
      bed_mesh.position.z -= FLOOR_LENGTH/2-FLOOR_LENGTH*(1-WALL_LEFT_LENGTH)-2.5;

      bed_mesh.castShadow = true;
      scene.add(bed_mesh);
    });

    //Car model

    var car_color = new THREE.Color(0.8, 1, 0.6);
    var car_material = new THREE.MeshPhongMaterial();

    car_material.color = car_color;
    car_material.shininess = 0;

    var loader1 = new THREE.PLYLoader();
    var car_mesh = null;
    loader1.load('Final Models/car1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(20 / size.length(), 20 / size.length(), 20 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);

      combined.multiply(tra);
      combined.multiply(sca);

      car_mesh = new THREE.Mesh(geometry, car_material);

      car_mesh.applyMatrix(sca);
      car_mesh.name = "loaded_mesh_1";

      car_mesh.position.x += FLOOR_WIDTH/3 + 2.5;
      car_mesh.position.y += 1.5;
      car_mesh.position.z += FLOOR_LENGTH/2 - geometry_wall_parallel.parameters.depth/2 - (FLOOR_LENGTH*0.2)/2;

      car_mesh.castShadow = true;
      scene.add(car_mesh);
    });


    //Shelf model

    var shelf_color = new THREE.Color(0.8, 1, 0.6);
    var shelf_material = new THREE.MeshPhongMaterial();

    shelf_material.color = shelf_color;
    shelf_material.shininess = 0;

    var loader2 = new THREE.PLYLoader();
    var shelf_mesh = null;
    loader2.load('Final Models/shelf1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(40 / size.length(), 40 / size.length(), 40 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);

      combined.multiply(tra);
      combined.multiply(sca);

      shelf_mesh = new THREE.Mesh(geometry, shelf_material);

      shelf_mesh.applyMatrix(sca);
      shelf_mesh.name = "loaded_mesh_2";
      shelf_mesh.position.x -= FLOOR_WIDTH/3-FLOOR_WIDTH/3 + 4;
      shelf_mesh.position.z -= FLOOR_LENGTH/2*(1-WALL_LEFT_LENGTH) - FLOOR_LENGTH*0.1 - 10.45;


      shelf_mesh.castShadow = true;
      scene.add(shelf_mesh);
    });

    //Fridge model

    var fridge_color = new THREE.Color(0.8, 1, 0.6);
    var fridge_material = new THREE.MeshPhongMaterial();

    fridge_material.color = fridge_color;
    fridge_material.shininess = 0;

    var loader3 = new THREE.PLYLoader();
    var fridge_mesh = null;
    loader3.load('Final Models/fridge1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var rot = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(15 / size.length(), 15 / size.length(), 15 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);
      rot.makeRotationY(2*Math.PI);

      combined.multiply(tra);
      combined.multiply(sca);

      fridge_mesh = new THREE.Mesh(geometry, fridge_material);

      fridge_mesh.applyMatrix(sca);
      fridge_mesh.applyMatrix(rot);
      fridge_mesh.name = "loaded_mesh_3";

      fridge_mesh.position.x -= FLOOR_WIDTH/2-76.4;
      fridge_mesh.position.z -= FLOOR_LENGTH/2-FLOOR_LENGTH*(1-WALL_LEFT_LENGTH) -15.7;

      fridge_mesh.castShadow = true;
      scene.add(fridge_mesh);
    });

  //dishwasher model

    var dishwasher_color = new THREE.Color(0.8, 1, 0.6);
    var dishwasher_material = new THREE.MeshPhongMaterial();

    dishwasher_material.color = dishwasher_color;
    dishwasher_material.shininess = 0;

    var loaderA = new THREE.PLYLoader();
    var dishwasher_mesh = null;
    loaderA.load('Final Models/dishwasher1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var rot = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(10 / size.length(), 10 / size.length(), 10 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);
     // rot.makeRotationY(-3*Math.PI/2);

      combined.multiply(tra);
      combined.multiply(sca);

      dishwasher_mesh = new THREE.Mesh(geometry, dishwasher_material);

      dishwasher_mesh.applyMatrix(sca);
     // dishwasher_mesh.applyMatrix(rot);
      dishwasher_mesh.name = "loaded_mesh_A";

      dishwasher_mesh.position.x -= FLOOR_WIDTH/2-69.8 ;
      dishwasher_mesh.position.z -= FLOOR_LENGTH/2-FLOOR_LENGTH*(1-WALL_LEFT_LENGTH) - 14.3;

      dishwasher_mesh.castShadow = true;
      scene.add(dishwasher_mesh);
    });
    
    //sink model

    var sink_color = new THREE.Color(0.8, 1, 0.6);
    var sink_material = new THREE.MeshPhongMaterial();

    sink_material.color = sink_color;
    sink_material.shininess = 0;

    var loaderB = new THREE.PLYLoader();
    var sink_mesh = null;
    loaderB.load('Final Models/sink1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var rot = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(13 / size.length(), 13 / size.length(), 13 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);
     // rot.makeRotationY(-3*Math.PI/2);

      combined.multiply(tra);
      combined.multiply(sca);

      sink_mesh = new THREE.Mesh(geometry, sink_material);

     sink_mesh.applyMatrix(sca);
	
     // sink_mesh.applyMatrix(rot);
      sink_mesh.name = "loaded_mesh_B";

      sink_mesh.position.x -= FLOOR_WIDTH/2-62.4 ;
      sink_mesh.position.z -= FLOOR_LENGTH/2-FLOOR_LENGTH*(1-WALL_LEFT_LENGTH) - 15;

      sink_mesh.castShadow = true;
      scene.add(sink_mesh);
    });
    
     //stove model

    var stove_color = new THREE.Color(0.8, 1, 0.6);
    var stove_material = new THREE.MeshPhongMaterial();

    stove_material.color = stove_color;
   stove_material.shininess = 0;

    var loaderC = new THREE.PLYLoader();
    var stove_mesh = null;
    loaderC.load('Final Models/stove1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var rot = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(11 / size.length(), 11 / size.length(), 11 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);
      rot.makeRotationY(1.5*Math.PI);

      combined.multiply(tra);
      combined.multiply(sca);

      stove_mesh = new THREE.Mesh(geometry, stove_material);

     stove_mesh.applyMatrix(sca);
	
     stove_mesh.applyMatrix(rot);
     stove_mesh.name = "loaded_mesh_C";

      stove_mesh.position.x -= FLOOR_WIDTH/2-76.9 ;
     stove_mesh.position.z -= FLOOR_LENGTH/2-FLOOR_LENGTH*(1-WALL_LEFT_LENGTH) - 27;

      stove_mesh.castShadow = true;
      scene.add(stove_mesh);
    });
    
    
    //Lamp model

    var lamp_color = new THREE.Color(0.8, 1, 0.6);
    var lamp_material = new THREE.MeshPhongMaterial();

    lamp_material.color = lamp_color;
    lamp_material.shininess = 100;

    var loader4 = new THREE.PLYLoader();
    var lamp_mesh = null;
    loader4.load('Final Models/lamp1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(17 / size.length(), 17 / size.length(), 17 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);

      combined.multiply(tra);
      combined.multiply(sca);

      lamp_mesh = new THREE.Mesh(geometry, lamp_material);

      lamp_mesh.applyMatrix(sca);
      lamp_mesh.name = "loaded_mesh_4";

      lamp_mesh.position.x += 2;
      lamp_mesh.position.y += 5;

      lamp_mesh.castShadow = true;
      scene.add(lamp_mesh);
    });

    //Table model

    var table_color = new THREE.Color(0.8, 1, 0.6);
    var table_material = new THREE.MeshPhongMaterial();

    table_material.color = table_color;
    table_material.shininess = 0;

    var loader5 = new THREE.PLYLoader();
    var table_mesh = null;
    loader5.load('Final Models/tablestyle1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var rot = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(17 / size.length(), 17 / size.length(), 17 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);
      rot.makeRotationY(-Math.PI/2);

      combined.multiply(tra);
      combined.multiply(sca);

      table_mesh = new THREE.Mesh(geometry, table_material);

      table_mesh.applyMatrix(sca);
      table_mesh.applyMatrix(rot);
      table_mesh.name = "loaded_mesh_5";

      table_mesh.position.x += 10;

      table_mesh.castShadow = true;
      scene.add(table_mesh);
    });

    //Chair model

    var chair_color_1 = new THREE.Color(0.8, 1, 0.6);
    var chair_material_1 = new THREE.MeshPhongMaterial();

    chair_material_1.color = chair_color_1;
    chair_material_1.shininess = 0;

    //Chair 1

    var loader6 = new THREE.PLYLoader();
    var chair_mesh_1 = null;
    loader6.load('Final Models/chair1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var rot = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(10 / size.length(), 10 / size.length(), 10 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);
      rot.makeRotationY(-Math.PI/2);

      combined.multiply(tra);
      combined.multiply(sca);

      chair_mesh_1 = new THREE.Mesh(geometry, chair_material_1);

      chair_mesh_1.applyMatrix(sca);
      chair_mesh_1.applyMatrix(rot);
      chair_mesh_1.name = "loaded_mesh_6";

      chair_mesh_1.position.x += 2;

      chair_mesh_1.castShadow = true;
      scene.add(chair_mesh_1);
    });

    //Chair 2

    var chair_color_2 = new THREE.Color(0.8, 1, 0.6);
    var chair_material_2 = new THREE.MeshPhongMaterial();

    chair_material_2.color = chair_color_2;
    chair_material_2.shininess = 0;

    var loader7 = new THREE.PLYLoader();
    var chair_mesh_2 = null;
    loader7.load('Final Models/chair1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var rot = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(10 / size.length(), 10 / size.length(), 10 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);
      rot.makeRotationY(Math.PI/2);

      combined.multiply(tra);
      combined.multiply(sca);

      chair_mesh_2 = new THREE.Mesh(geometry, chair_material_2);

      chair_mesh_2.applyMatrix(sca);
      chair_mesh_2.applyMatrix(rot);
      chair_mesh_2.name = "loaded_mesh_7";

      chair_mesh_2.position.x += 14;

      chair_mesh_2.castShadow = true;
      scene.add(chair_mesh_2);
    });

    //Lamp_1 model

    var lamp_color_1 = new THREE.Color(0.8, 1, 0.6);
    var lamp_material_1 = new THREE.MeshPhongMaterial();

    lamp_material_1.color = lamp_color_1;
    lamp_material_1.shininess = 100;

    var loader8 = new THREE.PLYLoader();
    var lamp_mesh_1 = null;
    loader4.load('Final Models/lamp1.ply', function(geometry) {
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();

      var center = geometry.boundingBox.getCenter();
      var size = geometry.boundingBox.getSize();

      var sca = new THREE.Matrix4();
      var tra = new THREE.Matrix4();
      var combined = new THREE.Matrix4();

      sca.makeScale(17 / size.length(), 17 / size.length(), 17 / size.length());
      tra.makeTranslation (-center.x,-center.y,-center.z);

      combined.multiply(tra);
      combined.multiply(sca);

      lamp_mesh_1 = new THREE.Mesh(geometry, lamp_material_1);

      lamp_mesh_1.applyMatrix(sca);
      lamp_mesh_1.name = "loaded_mesh_8";

      lamp_mesh_1.position.x -= FLOOR_WIDTH/3+6;
      lamp_mesh_1.position.y += 5;

      lamp_mesh_1.castShadow = true;
      scene.add(lamp_mesh_1);
    });





/*---------------------Selector of models in the scene--------------------*/

    var raycaster = new THREE.Raycaster();

    //Boolean variables of each of the items

    var selectedObj_bed = false;
    var selectedObj_car = false;
    var selectedObj_shelf = false;
    var selectedObj_fridge = false;
    var selectedObj_lamp = false;
    var selectedObj_dishwasher = false;
    var selectedObj_sink= false;
    var selectedObj_stove= false;
    var selectedObj_table = false;
    var selectedObj_chair_1 = false;
    var selectedObj_chair_2 = false;
    var selectedObj_lamp_1 = false;


    function onDocumentMouseDown(event) {

      var mouse = new THREE.Vector2;
      mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
      mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      var intersects = raycaster.intersectObjects(scene.children, false);

      if (intersects.length > 0) {

        //Bed selector

        if ((intersects[0].object.name == "loaded_mesh") && (!selectedObj_bed)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_bed = true;
        }
        if ((intersects[0].object.name != "loaded_mesh") && (selectedObj_bed)) {
          bed_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          bed_mesh.position.x = pos.x;
          bed_mesh.position.z = pos.z;
          selectedObj_bed = false;
        }

        //Car selector

        if ((intersects[0].object.name == "loaded_mesh_1") && (!selectedObj_car)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_car = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_1") && (selectedObj_car)) {
          car_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          car_mesh.position.x = pos.x;
          car_mesh.position.z = pos.z;
          selectedObj_car = false;
        }

        //Self selector

        if ((intersects[0].object.name == "loaded_mesh_2") && (!selectedObj_shelf)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_shelf = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_2") && (selectedObj_shelf)) {
          shelf_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          shelf_mesh.position.x = pos.x;
          shelf_mesh.position.z = pos.z;
          selectedObj_shelf = false;
        }

        //Fridge selector

        if ((intersects[0].object.name == "loaded_mesh_3") && (!selectedObj_fridge)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_fridge = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_3") && (selectedObj_fridge)) {
          fridge_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          fridge_mesh.position.x = pos.x;
          fridge_mesh.position.z = pos.z;
          selectedObj_fridge = false;
        }
	  
	   //Dishwasher selector

        if ((intersects[0].object.name == "loaded_mesh_A") && (!selectedObj_dishwasher)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_dishwasher = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_A") && (selectedObj_dishwasher)) {
          dishwasher_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          dishwasher_mesh.position.x = pos.x;
          dishwasher_mesh.position.z = pos.z;
          selectedObj_dishwasher = false;
        }
	  
	   //Sink selector

        if ((intersects[0].object.name == "loaded_mesh_B") && (!selectedObj_sink)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_sink = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_B") && (selectedObj_sink)) {
          sink_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          sink_mesh.position.x = pos.x;
          sink_mesh.position.z = pos.z;
          selectedObj_sink= false;
        }
	  
	    //Stove selector

        if ((intersects[0].object.name == "loaded_mesh_C") && (!selectedObj_stove)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_stove= true;
        }
        if ((intersects[0].object.name != "loaded_mesh_C") && (selectedObj_stove)) {
          stove_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          stove_mesh.position.x = pos.x;
          stove_mesh.position.z = pos.z;
          selectedObj_stove= false;
        }

        //Lamp selector

        if ((intersects[0].object.name == "loaded_mesh_4") && (!selectedObj_lamp)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_lamp = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_4") && (selectedObj_lamp)) {
          lamp_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          lamp_mesh.position.x = pos.x;
          lamp_mesh.position.z = pos.z;
          selectedObj_lamp = false;
        }

        //Table selector

        if ((intersects[0].object.name == "loaded_mesh_5") && (!selectedObj_table)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_table = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_5") && (selectedObj_table)) {
          table_mesh.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          table_mesh.position.x = pos.x;
          table_mesh.position.z = pos.z;
          selectedObj_table = false;
        }

        //Chair_1 selector

        if ((intersects[0].object.name == "loaded_mesh_6") && (!selectedObj_chair_1)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_chair_1 = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_6") && (selectedObj_chair_1)) {
          chair_mesh_1.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          chair_mesh_1.position.x = pos.x;
          chair_mesh_1.position.z = pos.z;
          selectedObj_chair_1 = false;
        }

        //Chair_2 selector

        if ((intersects[0].object.name == "loaded_mesh_7") && (!selectedObj_chair_2)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_chair_2 = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_7") && (selectedObj_chair_2)) {
          chair_mesh_2.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          chair_mesh_2.position.x = pos.x;
          chair_mesh_2.position.z = pos.z;
          selectedObj_chair_2 = false;
        }

        //Lamp_1 selector

        if ((intersects[0].object.name == "loaded_mesh_8") && (!selectedObj_lamp_1)) {
          console.log("Item selected");
          intersects[0].object.material.color = new THREE.Color(1, 0.5, 0.5);
          selectedObj_lamp_1 = true;
        }
        if ((intersects[0].object.name != "loaded_mesh_8") && (selectedObj_lamp_1)) {
          lamp_mesh_1.material.color = new THREE.Color(0.8, 1, 0.6);
          var pos = intersects[0].point;
          console.log("Item placed");
          lamp_mesh_1.position.x = pos.x;
          lamp_mesh_1.position.z = pos.z;
          selectedObj_lamp_1 = false;
        }

      }
    }

    function buildWalls() {
      var wall_bottom_out = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_parallel_out, 1, WallSideEnum.front);
      wall_bottom_out.position.y += (geometry_wall_parallel.parameters.height / 2);
      wall_bottom_out.position.z += FLOOR_LENGTH / 2 - geometry_wall_parallel.parameters.depth / 2;
      scene.add(wall_bottom_out);

      var wall_top_out = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_parallel_04, 1, WallSideEnum.back);
      wall_top_out.position.y+=(geometry_wall_parallel.parameters.height/2);
      wall_top_out.position.z-=FLOOR_LENGTH/2 - geometry_wall_parallel.parameters.depth/2;
      scene.add(wall_top_out);

      var wall_left_out = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_orthogonal_08, 1, WallSideEnum.left);
      wall_left_out.position.y+=(geometry_wall_orthogonal.parameters.height/2);
      wall_left_out.position.x-=FLOOR_WIDTH/2 - geometry_wall_orthogonal.parameters.width/2;
      wall_left_out.position.z+=FLOOR_LENGTH/2*(1-WALL_RIGHT_LENGTH) - OFFSET;
      scene.add(wall_left_out);

      var wall_right_out = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_orthogonal_08, 1, WallSideEnum.right);
      wall_right_out.position.y += (geometry_wall_orthogonal.parameters.height / 2);
      wall_right_out.position.x += FLOOR_WIDTH / 2 - geometry_wall_orthogonal.parameters.width / 2;
      wall_right_out.position.z += FLOOR_LENGTH / 2 * (1 - WALL_RIGHT_LENGTH) - OFFSET;
      scene.add(wall_right_out);

      var wall_bottom_10 = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_parallel, 1, WallSideEnum.none);
      wall_bottom_10.position.y += (geometry_wall_parallel.parameters.height / 2);
      wall_bottom_10.position.z += FLOOR_LENGTH / 2 - geometry_wall_parallel.parameters.depth / 2 - FLOOR_LENGTH * 0.2;
      scene.add(wall_bottom_10);

      var wall_top_left = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_parallel_03, 1, WallSideEnum.none);
      wall_top_left.position.y+=(geometry_wall_parallel.parameters.height/2);
      wall_top_left.position.x-=FLOOR_WIDTH/2*(1-WALL_TOP_WIDTH) - OFFSET;
      wall_top_left.position.z-=FLOOR_LENGTH/2-FLOOR_LENGTH*(1-WALL_LEFT_LENGTH) - geometry_wall_parallel.parameters.depth/2;
      scene.add(wall_top_left);

      var wall_top_right= loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_parallel_02, 1, WallSideEnum.none);
      wall_top_right.position.y+=(geometry_wall_parallel.parameters.height/2);
      wall_top_right.position.x+=FLOOR_WIDTH/2*(1-0.25) - OFFSET;
      wall_top_right.position.z-=FLOOR_LENGTH/2-FLOOR_LENGTH*(1-WALL_LEFT_LENGTH) - geometry_wall_parallel.parameters.depth/2 - 12;
      scene.add(wall_top_right);


      var wall_left_04 = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_orthogonal_04, 1, WallSideEnum.none);
      wall_left_04.position.y+=(geometry_wall_orthogonal.parameters.height/2);
      wall_left_04.position.x-=FLOOR_WIDTH/2-FLOOR_WIDTH/2*(1-WALL_TOP_WIDTH) - 2;
      wall_left_04.position.z+=FLOOR_LENGTH/2*(1-WALL_LEFT_LENGTH) - FLOOR_LENGTH*0.1 - OFFSET;
      scene.add(wall_left_04);

      var wall_left_02 = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_orthogonal_02, 1, WallSideEnum.none);
      wall_left_02.position.y+=(geometry_wall_orthogonal.parameters.height/2);
      wall_left_02.position.x-=FLOOR_WIDTH/2-FLOOR_WIDTH/2*(1-WALL_TOP_WIDTH) + 6;
      wall_left_02.position.z+=FLOOR_LENGTH/2 - geometry_wall_parallel.parameters.depth/2 - (FLOOR_LENGTH*0.2)/2;
      scene.add(wall_left_02);

      var wall_right_02 = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_orthogonal_02, 1, WallSideEnum.none);
      wall_right_02.position.y+=(geometry_wall_orthogonal.parameters.height/2);
      wall_right_02.position.x+=FLOOR_WIDTH/2-FLOOR_WIDTH/2*(1-WALL_TOP_WIDTH) + 5 ;
      wall_right_02.position.z+=FLOOR_LENGTH/2 - geometry_wall_parallel.parameters.depth/2 - (FLOOR_LENGTH*0.2)/2;
      scene.add(wall_right_02);

      var wall_diagonaltop_right = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_diagonal, 1, WallSideEnum.right);
      var rot = new THREE.Matrix4();
      rot.makeRotationY(0.8);
      wall_diagonaltop_right.applyMatrix(rot);
      wall_diagonaltop_right.position.y+=(geometry_wall_orthogonal.parameters.height/2);
      wall_diagonaltop_right.position.x+=FLOOR_WIDTH/2-FLOOR_WIDTH/2*(1-WALL_TOP_WIDTH) + 14.5 ;
      wall_diagonaltop_right.position.z-=FLOOR_LENGTH/2 - geometry_wall_parallel.parameters.depth/2 - (FLOOR_LENGTH*0.2)/2 + OFFSET;
      scene.add(wall_diagonaltop_right);

      var wall_diagonaltop_left = loadTexture('http://localhost:8000/img/txtr_white_wall.jpg', geometry_wall_diagonal, 1, WallSideEnum.left);
      var rot = new THREE.Matrix4();
      rot.makeRotationY(-0.8);
      wall_diagonaltop_left.applyMatrix(rot);
      wall_diagonaltop_left.position.y+=(geometry_wall_orthogonal.parameters.height/2);
      wall_diagonaltop_left.position.x-=FLOOR_WIDTH/2-FLOOR_WIDTH/2*(1-WALL_TOP_WIDTH) + 14.5 ;
      wall_diagonaltop_left.position.z-=FLOOR_LENGTH/2 - geometry_wall_parallel.parameters.depth/2 - (FLOOR_LENGTH*0.2)/2 + OFFSET;
      scene.add(wall_diagonaltop_left);
    }

    var gui;
    function buildGui() {
       gui = new dat.GUI();
       var params = {
         cameralight_intensity: cameraLight.intensity,
         livingroom_light: livingroom_light.intensity,
       }
       gui.add( params, 'cameralight_intensity', 0, 3 ).onChange( function ( val ) {
         cameraLight.intensity=val;
       } );
       gui.add( params, 'livingroom_light', 0, 3 ).onChange( function ( val ) {
         livingroom_light.intensity=val;
       } );
       //TODO Add Texture Changer

       gui.close();
     }

    //This allows to capture the clicks of the mouse for moving elements
    document.addEventListener('mousedown', onDocumentMouseDown, false);

    buildGui();

  </script>

</body>

</html>
