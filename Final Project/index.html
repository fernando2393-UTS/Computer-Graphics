<html>

<head>
  <title>Final Computer Graphics Project</title>
  <link rel="stylesheet" type="text/css" href="CSS/style.css">
</head>

<style>
  body {
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }
</style>

<body>
  <!--include the three.js library-->
  <script src="js/three.js">
  </script>
  <!--and the trackball code-->
  <script src="js/OrbitControls.js">
  </script>

  <!-- <div id="texture">
  Introduce the texture:
  <form id="texture_form">
    <select id="txt">
      <option value="img/brick_bump.jpg">Bricks</option>
      <option value="img/wood_1.jpg">Wood 1</option>
      <option value="img/wood_2.jpg">Wood 2</option>
    </select>
  </form>
  </div> -->



  <script>

    var FLOOR_WIDTH = 60; //x-axis
    var FLOOR_HEIGHT = 0.1; //y-axis
    var FLOOR_LENGTH = 90; //z-axis

    var WALL_HEIGHT = 15;
    var WALL_THICKNESS = 1;

    //Create the scene
    var scene = new THREE.Scene();

    //Create the webgl renderer
    var renderer = new THREE.WebGLRenderer();

    renderer.setSize(window.innerWidth, window.innerHeight);

    //Add the renderer to the current document
    document.body.appendChild(renderer.domElement);

    //Camera creation
    var ratio = window.innerWidth / window.innerHeight;
    //Create the perspective camera
    var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 2000);
    camera.position.set(60, 25, 60);

    //Light addition -> Camera Light
    var cameraLight = new THREE.PointLight(new THREE.Color(1, 1, 1), (2));
    camera.add(cameraLight);
    scene.add(camera);

    var geometry_floor = new THREE.BoxGeometry(FLOOR_WIDTH, FLOOR_HEIGHT, FLOOR_LENGTH);
    var geometry_wall_parallel = new THREE.BoxGeometry(FLOOR_WIDTH, WALL_HEIGHT, WALL_THICKNESS);
    var geometry_wall_orthogonal = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, FLOOR_LENGTH);

    var floor = loadTexture('https://static.pexels.com/photos/235985/pexels-photo-235985.jpeg', geometry_floor);
    scene.add(floor);

    var wall_back = loadTexture('http://localhost:8000/img/wood_1.jpg', geometry_wall_parallel);
    wall_back.position.y+=(geometry_wall_parallel.parameters.height/2);
    wall_back.position.z+=FLOOR_LENGTH/2 - geometry_wall_parallel.parameters.depth/2;
    scene.add(wall_back);

    var wall_front = loadTexture('http://localhost:8000/img/wood_1.jpg', geometry_wall_parallel);
    wall_front.position.y+=(geometry_wall_parallel.parameters.height/2);
    wall_front.position.z-=FLOOR_LENGTH/2 - geometry_wall_parallel.parameters.depth/2;
    scene.add(wall_front);

    var wall_left = loadTexture('http://localhost:8000/img/wood_1.jpg', geometry_wall_orthogonal);
    wall_left.position.y+=(geometry_wall_orthogonal.parameters.height/2);
    wall_left.position.x-=FLOOR_WIDTH/2 - geometry_wall_orthogonal.parameters.width/2;
    scene.add(wall_left);

    var wall_right = loadTexture('http://localhost:8000/img/wood_1.jpg', geometry_wall_orthogonal);
    wall_right.position.y+=(geometry_wall_orthogonal.parameters.height/2);
    wall_right.position.x+=FLOOR_WIDTH/2 - geometry_wall_orthogonal.parameters.width/2;
    scene.add(wall_right);


        //Resizing function -> adjust cube position and size to the window size
        var MyResize = function() {
          var width = window.innerWidth;
          var height = window.innerHeight;
          //Update renderer size
          renderer.setSize(width, height);
          //Update camera aspect ratio
          camera.aspect = width / height;
          //Update projection matrix from the new values
          camera.updateProjectionMatrix();
          //Render the scene again
          renderer.render(scene, camera);
        }

        controls = new THREE.OrbitControls(camera);

        //Updating function
        var MyUpdateLoop = function() {
          controls.update();
          //Call the render with the scene and the camera
          renderer.render(scene, camera);
          //Finally perform a recursive call to update again
          //THis must be called because the mouse changes the camera position
          requestAnimationFrame(MyUpdateLoop);
        };

        requestAnimationFrame(MyUpdateLoop);
        var render = function() {
          requestAnimationFrame(render);
          renderer.render(scene, camera);
        };


        function loadTexture(uri, geometry) {
          var textureLoader = new THREE.TextureLoader();
          THREE.ImageUtils.crossOrigin = true;
          textureLoader.crossOrigin = true;
          var texture = new THREE.TextureLoader().load(uri);
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, 1);
          var material = new THREE.MeshLambertMaterial({
                map: texture
          });
          return new THREE.Mesh(geometry, material);
        }

  </script>

</body>

</html>
