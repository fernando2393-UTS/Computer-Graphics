<!DOCTYPE html>
<html lang="en">


<!--
______________________________________________________________________________________________________________________
F I N A L   P R O J E C T
Computer Graphics

@author Alexander Ebner
@author Hendrik Hangen
@author Fernando GarcÃ­a
@author Marlies Wagner
  
This project is submitted by the abovementioned authors as their final project for 32501 Computer Graphics, Autumn 2018
The structure of the files and code is as follows:
  - index.html contains the HTML-Webpage and the main Javascript application
  - folder 'css' contains the css stylesheet for the HTML-Webpage 
  - folder 'js' contains all referenced scripts
  - folder 'Final Modals' ???????
  - folder 'img' contains all the textures and images used for this project

_____________________________________________________________________________________________________________________
-->


<html>

<head>
  <meta charset="utf-8" />
  <title>Final Computer Graphics Project</title>
  <link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body>
  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/PLYLoader.js"></script>
  <script src="js/dat.gui.min.js"></script>
  <script src="js/house.js"></script>
  <script src="js/modeladder.js"></script>
  <script src="js/meshOps.js"></script>
  <script src="js/gui.js"></script>
  <script src="js/PointerLockControls.js"></script>
  
  <div id="blocker">
			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</div> 
		</div>
  
 

  <script>
    var scene;
    var camera;
    var cameraLight;
    var renderer;

    createScene();
    addCamera();

    addFloor();
    addWalls();
    addDoors();
    addWindows();
    addLighting();

    buildGui();


    var resize = function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    }

	var render = function () {
      requestAnimationFrame(render);
      renderer.render(scene, camera);
    };

    function createScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x93C47D);
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
    }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
    function addCamera() {
  	var camera, scene, renderer, controls;

				var element = document.body;

        instructions.addEventListener( 'click', function ( event ) {

          instructions.style.display = 'none';
          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
          element.requestPointerLock();

        }, false );

			var controlsEnabled = true;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
		      var vertex = new THREE.Vector3();
			var color = new THREE.Color();

			init();
			animate();

			function init() {
			
			var ratio = window.innerWidth/window.innerHeight;

                  camera = new THREE.PerspectiveCamera(45,ratio,0.00001,1000);

			scene = new THREE.Scene();

        var ambientlight = new THREE.AmbientLight(new THREE.Color(1,1,1),0.2);
        scene.add(ambientlight);

        cameraLight = new THREE.PointLight( new THREE.Color(1,1,1), 0.8 );
        camera.add( cameraLight );
        scene.add(camera);

				controls = new THREE.PointerLockControls( camera );

      				controls.enabled = true;
				scene.add( controls.getObject() );

				var onKeyDown = function ( event ) {
				
					switch ( event.keyCode ) {
						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
             	 break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						  case 32: // space
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;
					}
				};
				
				var onKeyUp = function ( event ) {

					switch( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;
					}
				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );

				if ( controlsEnabled == true ) {

				 var time = performance.now();
					var delta =  ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;
        				velocity.y = 0;

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveLeft ) - Number( moveRight );
					direction.normalize();

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );

					prevTime = time;
				}
				renderer.render( scene, camera );
			}
  }
 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
  /*  function addCamera() {

     var ratio = window.innerWidth/window.innerHeight;
    //create the perspective camera
    //for parameters see https://threejs.org/docs/#api/cameras/PerspectiveCamera
    var camera = new THREE.PerspectiveCamera(45,ratio,0.00001,1000);
    var Pos = new THREE.Vector3(0,10,0);
    camera.position.set(Pos.x,Pos.y,Pos.z);
    var Dir = new THREE.Vector3(0,0,1);
    camera.lookAt(Dir.x,Dir.y,Dir.z);

    var material_box = new THREE.MeshBasicMaterial();
    material_box.color=  new THREE.Color(0,0,0);
    material_box.wireframe=false;
    var geometry_box = new THREE.BoxGeometry(10,0.1,10,32,1,32);
 
    var BoxMesh = new THREE.Mesh(geometry_box,material_box);
    BoxMesh.position.y=-1;
    scene.add(BoxMesh);

    var moveForward=false;
    var moveLeft=false;
    var moveBackward=false;
    var moveRight=false;

    //final update loop

    const clock = new THREE.Clock();

    var speed=5;
    var angle=0;
    var MyUpdateLoop = function ( )
    {
      var delta = clock.getDelta();
      if (moveLeft==true)
      {
        angle+=speed*delta;
        Dir.x=Math.sin(angle);
        Dir.z=Math.cos(angle);
        Dir.normalize();
      }
      if (moveRight==true)
      {
        angle-=speed*delta;
        Dir.x=Math.sin(angle);
        Dir.z=Math.cos(angle);
        Dir.normalize();
      }
      if (moveForward==true)
      {
        Pos.x+=Dir.x*speed*delta;
        //Pos.y+=Dir.y*speed*delta;
        Pos.z+=Dir.z*speed*delta;
      }
      if (moveBackward==true)
      {
        Pos.x-=Dir.x*speed*delta;
        //Pos.y-=Dir.y*speed*delta;
        Pos.z-=Dir.z*speed*delta;
      }
      //recompute direction

      //call the render with the scene and the camera
      renderer.render(scene,camera);
      //finally perform a recoursive call to update again
      //this must be called because the mouse change the camera position
      //camera.rotation.x=0;
      //update the projection matrix given the new values
      //camera.updateProjectionMatrix();

      camera.position.set(Pos.x,Pos.y,Pos.z);
      camera.lookAt(Pos.x+Dir.x,Pos.y+Dir.y,Pos.z+Dir.z);
      camera.updateProjectionMatrix();
      requestAnimationFrame(MyUpdateLoop);

    };

    requestAnimationFrame(MyUpdateLoop);

    //this function is called when the window is resized
    var MyResize = function ( )
    {
      //get the new sizes
      var width = window.innerWidth;
      var height = window.innerHeight;
      //then update the renderer
      renderer.setSize(width,height);
      //and update the aspect ratio of the camera
      camera.aspect = width/height;

      //update the projection matrix given the new values
      camera.updateProjectionMatrix();

      //and finally render the scene again
      renderer.render(scene,camera);
    };


    var onKeyDown = function ( event ) {

      switch ( event.keyCode ) {

        case 38: // up
        case 87: // w
          moveForward = true;
          break;

        case 37: // left
        case 65: // a
          moveLeft = true;
          break;

        case 40: // down
        case 83: // s
          moveBackward = true;
          break;

        case 39: // right
        case 68: // d
          moveRight = true;
          break;

      }

    };

    var onKeyUp = function ( event ) {

      switch( event.keyCode ) {

        case 38: // up
        case 87: // w
          moveForward = false;
          break;

        case 37: // left
        case 65: // a
          moveLeft = false;
          break;

        case 40: // down
        case 83: // s
          moveBackward = false;
          break;

        case 39: // right
        case 68: // d
          moveRight = false;
          break;

      }
    };

   // link the resize of the window to the update of the camera
     window.addEventListener( 'resize', MyResize);

     document.addEventListener( 'keydown', onKeyDown, false );
     document.addEventListener( 'keyup', onKeyUp, false );
   }
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /*  function addCamera() {
      var ratio = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 2000);
      camera.position.set(60, 25, 60);
      cameraLight = new THREE.PointLight(new THREE.Color(1, 1, 1), (0.2));
      camera.add(cameraLight);
      scene.add(camera);
      controls = new THREE.OrbitControls(camera);
      
    /*  var ratio = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 2000);
      camera.position.set(60, 25, 60);
      cameraLight = new THREE.PointLight(new THREE.Color(1, 1, 1), (0.2));
      camera.add(cameraLight);
      scene.add(camera);
      controls = new THREE.OrbitControls(camera);
	}
	*/ 
 
    function addAxisHelper() {
      var axesHelper = new THREE.AxesHelper(300, 300, 300);
      scene.add(axesHelper);
    }
  </script>

</body>

</html>