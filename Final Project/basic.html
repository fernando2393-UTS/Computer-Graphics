<html>

<head>
  <title>Simple Geometry Test</title>
</head>

<style>
  body {
    margin: 0;
  }

  canvas {
    width: 100%;
    height: 100%;
  }
</style>

<body>
  <!--include the three.js library-->
  <script src="js/three.js">
  </script>
  <!--and the trackball code-->
  <script src="js/OrbitControls.js">
  </script>

  <style>
    body {
      font-family: Monospace;
      background-color: #000;
      color: #fff;
      margin: 0px;
      overflow: hidden;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
    }
  </style>

  <div id="info">
    <p>This is a threeJS Test<br>
  </div>
  <script>
    //Create the scene
    var scene = new THREE.Scene();

    //Create the webgl renderer
    var renderer = new THREE.WebGLRenderer();

    renderer.setSize(window.innerWidth, window.innerHeight);

    //Add the renderer to the current document
    document.body.appendChild(renderer.domElement);

    //Camera creation

    var ratio = window.innerWidth / window.innerHeight;
    //Create the perspective camera
    var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);
    camera.position.set(10, 10, 0.3);

    //Light addition -> Camera Light
    var cameraLight = new THREE.PointLight(new THREE.Color(1, 1, 1), (2));
    camera.add(cameraLight);
    scene.add(camera);


    //Texture creation
    // var imgTexture = new THREE.TextureLoader().load("img/brick_bump.jpg");
    // imgTexture.wrapS = imgTexture.wrapT = THREE.RepeatWrapping;
    // imgTexture.anisotropy = 16;
    // imgTexture = null;

    //Create the mesh of a sphere
    //Texture loader
    var textureLoader = new THREE.TextureLoader();
    var geometry_cube = new THREE.BoxGeometry(10, 10, 0.3);
    var cube;
    THREE.ImageUtils.crossOrigin = true;
    textureLoader.crossOrigin = true;

    // function input_texture(){
    //
    // } 

    textureLoader.load('https://static.pexels.com/photos/235985/pexels-photo-235985.jpeg', function(texture) {
          // this code makes the texture repeat
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(1, 1);
          // set the texture as the map for the material
          var material = new THREE.MeshLambertMaterial({
            map: texture
          });
          cube = new THREE.Mesh(geometry_cube, material);
          scene.add(cube);
          cube.position.z -= 2;
          render();
        });


        // var color = new THREE.Color("#7833aa");
        // var material_cube = new THREE.MeshLambertMaterial({
        //   color: color.getHex()
        // });
        // //Set renderer to wireframe
        // material_cube.wireframe = true;
        // var geometry_cube = new THREE.SphereGeometry(2, 32, 32);
        // var cube = new THREE.Mesh(geometry_cube, material_cube);
        //
        // scene.add(cube); cube.position.z -= 6;

        //Light addition
        // var light = new THREE.PointLight( 0xFFFFFF , 1.5);
        // light.position.set( 10, 0, 80 );
        // scene.add( light );

        //Resizing function -> adjust cube position and size to the window size
        var MyResize = function() {
          var width = window.innerWidth;
          var height = window.innerHeight;
          //Update renderer size
          renderer.setSize(width, height);
          //Update camera aspect ratio
          camera.aspect = width / height;
          //Update projection matrix from the new values
          camera.updateProjectionMatrix();
          //Render the scene again
          renderer.render(scene, camera);
        }

        controls = new THREE.OrbitControls(camera);

        //Updating function
        var MyUpdateLoop = function() {
          controls.update();
          //Call the render with the scene and the camera
          renderer.render(scene, camera);
          //Finally perform a recursive call to update again
          //THis must be called because the mouse changes the camera position
          requestAnimationFrame(MyUpdateLoop);
        };

        requestAnimationFrame(MyUpdateLoop);
        var render = function() {
          requestAnimationFrame(render);
          mesh.rotation.x += 0.1;
          renderer.render(scene, camera);
        };

  </script>
</body>

</html>
